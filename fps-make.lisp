(in-package :maxima)

(defun fps-check-varlist (vars)
  (unless (and ($listp vars)
               (every #'symbolp (cdr vars)))
    (merror "vars must be a nonempty list of symbols")))

(defmfun $list_to_fps (lst var long?)
  (unless (or (not long?) (eq long? t))
    (merror "long? should be true or false."))
  (unless ($listp lst)
    (merror "lst should be a list (of coefficients)"))
  (unless (symbolp var)
    (merror "var should be a symbol"))
  (if long?
      `(($fps)
        ((lambda) ((mlist) $n)
         ((mcond)
          (($is) ((mlessp) $n ,(length (cdr lst))))
          ((mqapply array) ,lst ((mplus) $n 1)) t 0))
        ((mlist) ,var) -1)
      `(($fps)
        ((lambda) ((mlist) $n) ((mqapply array) ,lst ((mplus) $n 1)))
        ((mlist) ,var) ,(1- (length (cdr lst))))))

(defmfun $subvar_to_fps (subvar vars maxorder)
  (unless (symbolp subvar)
    (merror "subvar must be a symbol"))
  (unless (integerp maxorder)
    (merror "maxorder must be an integer"))
  (fps-check-varlist vars)
  `(($fps)
    ((lambda) ((mlist) n)
     (($apply) $subvar (($cons) ,subvar ((mlist) n))))
    ,vars ,maxorder))

(defmfun $function_to_fps (func vars maxorder)
  (unless (or (symbolp func)
              (and (not (atom func)) (equal (caar func) 'lambda)))
    (merror "Don't know how to interpret func as a function."))
  (fps-check-varlist vars)
  (let ((args (cons '(mlist)
                    (loop
                       for i from 1 to (length (cdr vars))
                       collecting (intern (format nil "$X~D" i))))))
    `(($fps) ((lambda) ,args (($apply) ,func ,args)) ,vars ,maxorder)))
