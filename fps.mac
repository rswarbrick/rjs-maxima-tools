load("utils.mac")$

/*
  Represent a power series in n variables x1,...,xn as some sort of
  assoc which allows

     I := (i,j,k) |-> coeff of x^i y^j z^k =: A[I]

  The general representation is that such a power series *is* a
  function taking n arguments and returning an expression for the
  coefficient. We also store a non-negative integer K and guarantee
  that, for sum(I) <= K, the function will return the correct
  coefficient. We don't define the results of calling the function for
  a higher degree index. K=-1 means that the power series is defined
  for all degrees.

  The composite of two power series F(G(x1,..,xn)) (only defined if
  the zero-order term in G is zero) is represented by compose(F,G). If
  F had more than one variable, you'd write something like
  compose(F,G1,G2).
*/
defstruct (fps (f, vars, maxdeg))$

fpsp (expr) :=
  is(not(atom(expr)) and op(expr) = 'fps and
  fps_validp(expr))$

fps_validp (f) :=
  is(listp(f@vars) and is(length(f@vars) > 0) and
     every(atom, f@vars) and
     integerp(f@maxdeg) and
     is(f@maxdeg >= -1))$

fps_check_varlist (vars) :=
  if(not(listp(vars) and length(vars)>0 and every(atom, vars)))
  then error("vars must be a nonempty list of symbols")$

/*
  Generate a formal power series in one variable from a list of
  coefficients.

  Performs a shallow copy of lst.
*/
list_to_fps (lst, var) :=
  if not(listp(lst) and length(lst)>0) then
  error("lst must be nonempty.")
  elseif not(atom(var)) then
  error("var must be an atom")
  else
  block([f: new(fps)],
    f@f: buildq([cpy: copy(lst)], lambda([n], cpy[n+1])),
    f@vars: [var],
    f@maxdeg: length(lst)-1,
    f)$

/*
  Make a formal power series from a subscripted variable.
*/
subvar_to_fps (x, vars, maxpow) := block([f: new(fps)],
  if(not(symbolp(x))) then error("x should be a symbol"),
  fps_check_varlist (vars),
  f@f: buildq([a: makelist(concat('x,i),i,1,length(vars)), x:x],
              lambda(a, apply(subvar, cons(x, a)))),
  f@vars: vars,
  f@maxdeg: maxpow,
  f)$

/*
  Make a formal power series from a function.
*/
function_to_fps (func, vars, maxpow) := block([f: new(fps)],
  if(not(symbolp(func) or (not(atom(func)) and op(func) = lambda)))
  then error("func should be a name of a function or a lambda form."),
  fps_check_varlist (vars),
  f@f: buildq([a: makelist(concat('x,i),i,1,length(vars)), f:func],
              lambda(a, apply(f, a))),
  f@vars: vars,
  f@maxdeg: maxpow,
  f)$

/*
  Get the coefficient for the indices list I. If given an integer,
  treats it as a one-element list.
*/
fps_get_coeff (fps, I) := block([J],
  if (integerp(I)) then J: [I] else J: I,
  fps_get_coeff_sanity_check (fps, J),
  apply(fps@f, J))$

fps_get_coeff_sanity_check (fps, I) := block([],
  if (not(fpsp(fps) and listp(I))) then
  error("Needs a list of indices and a FPS"),

  if(not(length(fps@vars) = length(I))) then
  error("Wrong number of indices."),

  for i in I do
  if(not(integerp(i) and i>=0)) then
  error("I must be a list of non-neg integers"),

  block([tot: lsum(x,x,I)],
    if (is(fps@maxdeg >= 0 and tot > fps@maxdeg)) then
    error("FPS not defined to that degree.")));

/*
  Generate the partial sum of FPS up to the max degree requested.
*/
fps_term (fps, I) :=
  if(not(length(fps@vars) = length(I))) then
  error("Length of variables # length of indices")
  else
  product((fps@vars)[k]^I[k],k,1,length(I))*fps_get_coeff(fps, I)$

fps_partial_sum_posorder (fps, order) :=
  block([parts: integer_partitions(order, length(fps@vars)),
         acc: 0],
    for p in parts do
    for I in permutations(p) do
    acc: acc + num_identical_perms(I)*fps_term(fps, I),
    acc)$

fps_partial_sum_order (fps, order) :=
  if is(order < 0) then 0
  elseif is(order = 0) then
  fps_term(fps, map(lambda([x], 0), fps@vars))
  else
  fps_partial_sum_posorder (fps, order)$

fps_partial_sum_fps (fps, maxorder) := block([acc: 0],
  for n: 0 thru maxorder do
  acc: acc + fps_partial_sum_order(fps,n),
  acc)$

fps_find_bound_variables (expr) := block([fpsvars: {}],
  scanmap(lambda([x],
                 if(fpsp(x))
                 then fpsvars: union(setify(x@vars),fpsvars)
                 else x), expr),
          fpsvars)$

/*
  Returns the constant term wrt fpsvars (which must be set) in the
  expression given. Used after partial expansion to check zero-order
  terms.
*/
fps_constant_term (expr) := block([ans: expr],
  for v in fpsvars do ans: subst(0,v,ans),
  ans)$

/*
  Deal with composition for fps_partial_sum_. Only works with fpsvars
  set
*/
fps_partial_sum_compose (f, glist, maxorder) :=
  if not(fpsp (f))
  then error("Compose only defined for first arg an fps")
  elseif not(length(f@vars) = length(glist))
  then error("Incorrect number of arguments in composition")
  else
  block([expansions: map(lambda([g], fps_partial_sum_(g,maxorder)),
                         glist),
         dummys: map(lambda([x], gensym("fps")), f@vars),
         realvars: f@vars,
         fexpansion],
        if not(every(lambda([e], is(fps_constant_term(e)=0)),
                     expansions))
        then error("Nonzero constant term")
        else
        f@vars: dummys,
        fexpansion: fps_partial_sum_fps (f, maxorder),
        f@vars: realvars,
        for i: 1 thru length(dummys) do
        fexpansion: ratexpand(subst(expansions[i], dummys[i],
                                    fexpansion)),
        fexpansion)$

fps_partial_sum_ (expr, maxorder) :=
  if (is(atom(expr) or freeof('fps, expr))) then expr
  else block([o: op(expr)],
    if is(o='fps) then
      if is(fps_validp(expr)) then fps_partial_sum_fps (expr,maxorder)
      else error ("Invalid formal power series.")
    elseif is(member(o, ["+","*","-"])) then
      ratexpand(apply(o, map(lambda([x],fps_partial_sum_(x,maxorder)),
                          args(expr))))
    elseif is(o = "^" and integerp(second(expr)) and second(expr)>=0)
    then
      ratexpand(fps_partial_sum_(first(expr), maxorder)^second(expr))
    elseif is(o = 'compose) then
      fps_partial_sum_compose (first(expr),rest(args(expr)),maxorder)
    else
      error ("Cannot handle operator"))$

/* True for atoms or powers of atoms */
varpowp (expr) :=
  is(atom(expr) or
     (op(expr) = "^" and
      atom(first(expr)) and integerp(second(expr))))$

/* Uses dynamically bound fpsvars */
freeof_fpsvars (expr) :=
  every(lambda([v], freeof(v, expr)), fpsvars)$

/*
  Tests to see whether an expression is a monomial in the variables we
  care about. Note that we use dynamically bound fpsvars, since if
  we're looking at an fps in x,y then (a^2+1)*x^2*y will be
  represented as

  ((MTIMES SIMP)
   ((MPLUS SIMP) 1 ((MEXPT SIMP) $A 2))
   ((MEXPT SIMP) $X 2) $Y)

  and if we drilled down further in code to find monomial orders it'd
  give the wrong answer!
*/
fps_monomialp (expr) :=
  is(varpowp (expr) or
     (op(expr)="*" and
      every(lambda([u], is(varpowp(u) or freeof_fpsvars(u))),
            args(expr))))$

/*
  Uses dynamically bound fpsvars.
*/
fps_monomial_power (m) :=
  if (freeof_fpsvars (m)) then 0
  elseif atom(m) then 1
  elseif is(varpowp(m)) then second(m)
  elseif not(op(m) = "*") then error("Invalid monomial")
  else lsum(fps_monomial_power(e), e, args(m))$

/*
  Returns expr unless expr is a monomial of power higher than
  fpsmaxpow, in which case it returns zero. Both fpsvars and fpsmaxpow
  should be dynamically bound. (This is used with scanmap).
*/
fps_kill_hidegrees (expr) :=
  if (not(fps_monomialp(expr)) or
      is(fps_monomial_power(expr) <= fpsmaxpow)) then expr
  else 0$

/*
  This calculates the partial sum up to maxorder of expr, an
  expression which might contain fps objects. Note this isn't a
  particularly efficient way to find the coefficient of a given term
  in the expansion for the power series.
*/
fps_partial_sum (expr, maxorder) := block(
  [fpsvars: fps_find_bound_variables (expr), fpsmaxpow: maxorder],
  scanmap(fps_kill_hidegrees,
          fps_partial_sum_ (expr, maxorder)))$
